# \[레슨] 01) Git Intro

Chapter: https://www.notion.so/01-Git-Github-Intro-73b0b49bff584045aa4161f050c7a813 File: %5B%E1%84%85%E1%85%A6%E1%84%89%E1%85%B3%E1%86%AB%5D%2001%20f6392/Git\_%ED%8A%B9%EA%B0%95\_%EC%9D%B8%ED%8A%B8%EB%A1%9C\_v2.0.pptx, %5B%E1%84%85%E1%85%A6%E1%84%89%E1%85%B3%E1%86%AB%5D%2001%20f6392/%EB%A7%A8%EB%B0%9C%EC%9D%98%EC%B2%AD%EC%B6%98\_%ED%8F%B0%ED%8A%B8.zip Module: https://www.notion.so/14cb4a1c64d54f72b1427ed2387979ef, https://www.notion.so/a0765375a8634d53ab8d0f45efe1f759, https://www.notion.so/e1b639b3017945268fad042a5772bfc9 진행상태: 완료 카테고리: 레슨

💡 해당 자료는 따로 교육생에게 제공되지 않습니다. Git 특강을 진행하는 강사가 PPT 내용을 좀 더 쉽게 파악할 수 있도록 만든 자료입니다.

## Git 강의 인트로 각 화면 설명

```
어떤 학문이나 기술을 배울 때, 왜 배우는지가 중요합니다. 
Git은 단기에 완벽하게 습득할 수 없기 때문에 Git을 왜 사용하는지 납득하고 앞으로도 
꾸준히 학습할 동기부여를 얻을 수 있도록 Why를 먼저 살펴봅니다.
```

***

```
인트로는 크게 두 가지로 나눌 수 있습니다.
하나는 왜 버전 관리가 필요한가? 그리고 그 버전 관리를 위해서 왜 Git을 사용하는가? 이고
다른 하나는 왜 포트폴리오를 관리하나? 그리고 그 포트폴리오 관리를 위해 왜 Github를 사용하는가?
입니다.
```

***

```
이제 첫번째로 왜 버전 관리가 필요한가? 그리고 버전 관리를 위해 왜 Git을 사용하는가?에
대해 알아보겠습니다.
```

***

```
Git의 사전적 정의는 분산 버전 관리 프로그램입니다.
```

***

```
그런데 여기 여러운 단어가 있네요. 분산? 일단 이 단어는 가리고 나머지를 먼저 보겠습니다.
버전, 관리, 프로그램 각각 단어는 우리가 너무나 일상생활에서 많이 접하던 단어입니다.
각각 어떤 뜻인지 살펴볼까요?
```

***

```
버전은 갤럭시 1, 2, 3, ~ 21 처럼 어떤 발명품, 기술 등의 특정 시점의 상태를 말합니다.
관리는 조금 추상적이지만 무언가를 더 발전시키거나 개선하는 것을 말합니다.
프로그램은 우리가 알고 있는 그 의미입니다.

이렇듯 각각의 단어 하나 하나를 살펴보면 너무 쉽습니다.
```

***

```
각각의 단어의 뜻을 알아보았으니, 이제 합쳐볼까요?
컴퓨터 소프트웨어의 특정 상태들을 관리하는 것? 이라고 할 수 있겠습니다.
```

***

```
하지만 아직 어렵습니다. 아마 교육생 분들은 이런 표정을 짓겠지요.
```

***

```
그러나 우리는 사실 이미 "버전 관리"의 개념을 알고 있고, 심지어 해본 적도 있습니다.
버전 관리는 우리가 배우기도 전에 이미 유전자 속에 각인 되어 있다고 할 수 있습니다.
```

***

```
학창시절 아마 이런식으로 과제나 레포트를 해본 경험이 있으실 겁니다.
"최종", "진짜 최종"도 결국은 각각 하나의 버전입니다.
다만 우리는 이러한 행위를 "버전 관리"라고 부르지 않았을 뿐입니다.

사실은 우리는 애초부터 "버전 관리"를 행해오고 있었던 겁니다.
```

***

```
다만 이런식의 버전관리는 문제가 조금 있습니다.
바로 "어떤게 진짜로 최종인가?" 를 알기가 어렵다는 것입니다.

단어의 "뉘앙스"만으로는 "최종"이 진짜 최종인가? "리얼 최종"이 진짜 최종인가? 알 수 없습니다.
```

***

```
그래서 우리는 조금 똑똑한 물음표(신원미상) 친구를 불러서 이 문제를 해결해 보려고 합니다.
이 친구는 이 문제를 어떻게 해결할까요? 버전 관리를 어떤 방식으로 개선해야 할까요?
```

***

```
물음표 친구는 "파일에 날짜와 시간을 적어봐!" 라고 답했습니다.
어떻게요? 바로 이렇게 입니다. (다음 화면)
```

***

```
이제 파일은 "최종", "진짜 최종" 과 같은 식으로 버전 관리 하지 않습니다.
각 파일의 이름에는 "날짜와 시간"이 쓰여있어서, 어느 레포트가 최종인지 쉽게 알 수 있습니다.

우리는 이렇게 버전 관리 방식을 한 단계 업그레이드 했습니다.
```

***

```
여기서 혹독한 가정을 하나 해보겠습니다. 만약 레포트 1개 당 1000장이면 어떨까요?
그게 왜 문제인지 모르시겠다구요?
```

***

```
바로 이런 문제가 있을 수 있습니다. 12월 2일과 12월 3일 레포트 사이의 차이점을 어떻게 알까요?
1개 당 1000장인데, 총 2000장을 일일히 비교하려면 엄청 많은 시간이 걸릴 겁니다.
```

***

```
우리는 또 물음표 친구를 불러서, 이 문제를 해결하려고 합니다.
"뉘앙스" -> "날짜와 시간" 으로 버전 관리 방식을 업그레이드 했듯이,
이번에도 버전 관리의 방식을 업그레이드 할 때가 되었습니다. 어떻게 해결할 수 있을까요?
```

***

```
물음표는 "변경사항만 기록하는 파일 자체를 따로 만들어 봐!" 라고 얘기합니다.
```

***

```
바로 이렇게 말이죠!

12월 01일 레포트에서 12월 02일 레포트로 수정할 때, 어떤 걸 수정했는지
그 변경사항을 "변경사항 파일"을 만들어서 따로 기록하라는 것입니다.

이렇게 되면, 2000장을 일일히 보지 않아도 "변경사항 파일"만 열면 변경 사항을 바로 알 수 있죠.
시간을 매우 단축했을 뿐 아니라, 사람의 실수도 줄어들게 했습니다.
우리는 또 버전 관리 방식을 한 단계 업그레이드 했습니다.
```

***

```
두 번째 혹독한 가정을 해봅시다. 만약 레포트 1개 당 이제 10억 장이라면 어떨까요?

10억장이면 아마 파일 1개당 1GB는 우습게 넘을 수 있습니다. 즉 용량이 매우 커지게됩니다.
용량이 커진다면 과제를 제출하거나 친구들과 공유하기 매우 어려워 질 겁니다.
```

***

```
우리는 용량 문제를 해결하기 위해서 한번 더 버전 관리 방식을 업그레이드 시킬 필요가 있습니다.

또 물음표 친구에게 물어보려고 합니다.

어떻게 하면 레포트도 다 살아있고, 변경 사항도 살아있으면서, 용량은 줄일 수 있을까요?
```

***

```
물음표는 "맨 마지막 최종 원본만 남기고, 이전 것들은 변경사항만 남겨!"라고 말합니다.
```

***

```
바로 이렇게 말이죠!

12월 05일 (최종파일)만 남기고, 나머지는 변경사항만 남기는 전략입니다.
```

***

```
정리해보자면 이렇게 파일을 저장하라는 것이죠.
```

***

```
그런데 아마 이런 의문이 들 수 있습니다.

내가 12월 04일의 변경사항이 아니라, 레포트의 모습을 보고싶다면 어떻게 하지?
12월 05일(최종파일)은 남아있지만, 12월 04일은 변경사항만 있기 때문에 불가능한거 아니야?

라고 말이죠.
```

***

```
하지만 가능합니다. 최종 파일에서 거슬러 올라가면 됩니다.

이게 무슨 말일까요?

쉽게 생각하면, 12월 05일(최종파일)에서 12월 05일의 변경사항을 제거하면,
그게 바로 12월 04일의 레포트가 아닐까요? 즉 변경사항을 취소하면 되지 않을까요?
```

***

```
교육생 분들의 이해를 위해, 이것을 그림으로도 설명해 보겠습니다.

기존의 방식 즉, 용량의 문제가 있기 전의 버전 관리에서는
각각의 버전마다 모든 사항을 저장했습니다. 즉 레포트의 원본이 각각 존재했었죠.

하지만 각각이 10억장이라서 1GB가 넘어가면 용량의 문제가 발생합니다.

그래서 아래의 개선 방식 즉, "버전을 변경할 때 마다의 변경 사항 + 최종 파일"만 남기게 되었죠.
이렇게 되면 각각이 1GB가 아니라, Ver4만 1GB이고, 나머지는 변경 사항이므로 용량이 적어집니다.

개선 방식에서는 Ver2의 모습을 어떻게 확인할까요? -> Ver 4에서 각각의 변경사항을 거스르면 됩니다
Ver4에서 "창문"과 "현관문"이라는 변경 사항을 거스르면? Ver2가 되지 않을까요?
```

***

```
그런데 우리는 기계가 아니라 사람입니다. 10억장의 레포트의 변경 사항을 거스른다는 것은
매우 고되고 오래 걸리는 작업이 될 것 같습니다.

그래서! 물음표가 "내가 천재니까 그 작업은 내가 해줄게!" 라고 얘기합니다.

물음표는 이렇게 얘기합니다.
"너가 12월 04일 레포트 보고 싶어? 그럼 말만해! 내가 알아서 거슬러 올라가 줄테니까!"
```

***

```
이제 우리는 이 물음표 친구를 "버전 관리 프로그램"이라고 부르겠습니다.

물음표는 천재였죠? 즉 물음표는 소프트웨어이기 때문에 매우 빠릅니다.

사용자는 어느 시점의 버전을 보고 싶은지 버전 관리 프로그램에게 시키기만 하면 됩니다.
```

***

```
그리고 변경 사항을 알아보자면, 이런 내용이 작성되어 있습니다.

"언제, 누가, 어디를(무엇을), 어떻게, 왜 변경하였는가?" (육하원칙)
```

***

```
근데, 버전 관리 프로그램은 이 변경사항 마저도 자신이 적어 주겠다고 합니다.

단지 사용자는 "왜 변경했는가?" 그 이유만 적어주면 됩니다. (이는 commit message를 의미)

우리가 배울 Git도 버전 관리 프로그램 중 하나입니다.
실제로 나중에 Git의 이론을 배울 때 아시겠지만, Git은 저 변경 사항을 자동으로 작성해줍니다.
```

***

```
자 이제 우리는 처음으로 다시 돌아왔습니다.

처음에 우리는 용어가 너무 어려워서 무슨 말인지 몰랐습니다.
이제는 "버전 관리 프로그램"이 무엇인지 대충 감이 오는 것 같습니다.
```

***

```
결국 버전 관리를 하는 이유는 딱 세 가지 "백업, 복구 협업"을 위해서 입니다.

백업은 레포트와 변경사항을 저장하는 것처럼, 과거의 자료들도 저장하는 것을 말합니다.
복구는 변경사항을 거슬러 올라가는 것 처럼, 예전 버전의 모습을 보여주는 것을 말합니다.
협업은 변경사항에 육하원칙을 적는 것 처럼, 일일히 협업자에게 전화나 문자를 보내서
       "너 왜 이거 바꿨어? 언제 바꿨어? 어딜 바꿨어?" 라고 물어보지 않아도 되는 것을 말합니다.

즉 "백업 복구 협업"을 위해 우리는 버전 관리라는 것을 할 것이고
버전 관리를 위해서 Git이라고 하는 프로그램을 사용할 것입니다.
```

***

```
이제 가려놨던 단어인 "분산"에 대해서 알아봅시다.
분산이란 뭘까요?
```

***

```
"분산"의 의미를 알기 위해서는, 그의 반대인 "중앙 집중식"과 비교하며 알아볼 필요가 있습니다.

중앙 집중식은 말 그대로 중앙에 서버 컴퓨터가 있고, 각 사용자는 중앙에서 파일을 받아와서
작업을 하고, 다시 중앙에 넣어 놓는 것을 말합니다.

여기서 중요한 건 저 그림을 이해하는 것이 아니라,
"각 사용자는 중앙에서 뭘 받아와서 다시 넣는다." 가 중요합니다.
```

***

```
그렇기 때문에 만약 중앙 서버 컴퓨터에 불이 난다면요?

각 사용자는 중앙에서 뭘 받아오지도 못하고, 다시 넣을 수도 없는 상태가 됩니다.
즉 모든 자료와 작업물을 잃어버리는 상태가 되는 것입니다.

반면에, 분산 버전관리는 각 사용자가 중앙에서 뭘 받아오고 넣는 형태가 아닙니다.
"분산"은 퍼져있는 것을 의미하는데요. 즉 각 사용자가 모든 것을 각자 다 가지고 있는 겁니다.
그렇기 때문에 중앙에서 받아오고 넣지 않고, 각 사용자가 자신의 컴퓨터 안에서만 작업을 하게 됩니다.
```

***

```
만약에 분산 버전 관리에서 중앙 서버에 불이 난다면 어떻게 될까요?

그래도 괜찮습니다. 어차피 각 사용자는 모든 것을 가지고 있기 때문이죠.
나중에 중앙 서버의 불이 꺼지고 복구하면, 각 사용자는 자신이 가지고 있는 파일을
중앙 서버에 넣으면 됩니다.

반대로 사용자 컴퓨터에 불이나도 괜찮습니다. 나중에 중앙에서 받아오면 됩니다!

이렇듯, 하나의 서버 컴퓨터에서 모든 것을 관리하는 것이 아니라,
중앙 서버와 각 사용자 모두가 따로따로 모든 것을 가지고 있는 형태를
"분산 버전 관리"라고 합니다.
```

***

```
지금까지 첫 번째 큰 그림인 왜 버전 관리를 하는가? 그리고 왜 Git을 쓰는가? 에 대해
알아보았습니다.

이제 두 번째로 왜 포트폴리오를 관리하나? 그리고 왜 이를 위해 Github를 사용하나?에 대해
알아봅시다.
```

***

```
여러분은 여행사의 인사팀장입니다. 다음에 나올 왼쪽, 오른쪽 지원자 중 어떤 분을
채용하시겠습니까? 직접 대답해 보시기 바랍니다.
```

***

```
왼쪽은 게시물이 3000개가 넘고, 팔로워도 많습니다.

오른쪽은 게시물이 없고, 팔로워도 없습니다.
```

***

```
당연히 왼쪽 지원자를 뽑을 것 같습니다.
높은 팔로워, 팔로우 때문일까요? 게시물이 많아서 일까요? 게시물이 예뻐서 일까요?

결국은 이런 것들로 알 수 있는 것이 "지원자의 열정, 성실함, 홍보 능력"입니다.
우리는 저 인스타그램 계정만 보고도 이 세 가지를 느낄 수 있습니다.
```

***

```
그럼 IT 회사도 이런 열정, 성실함, 능력을 보여줄 방법이 있지 않을까요?
네 맞습니다. 우리는 이것을 Github를 통해서 이제 보여줘야 합니다.

지금 나오는 화면은 이동욱 개발자님이라고 유명한 스타 개발자 중 한 분의 Github 계정입니다.
왼쪽은 프로필이 있고, 가운데에는 인스타그램의 게시물처럼 자신의 프로젝트가 올라와 있네요.
아래는 한칸 한칸이 달력인데, 이는 그 날 무언가를 올렸다면 초록색으로 변하는 칸입니다.
이를 소위 "잔디를 심는다."라고 표현을 하고 이것을 매일매일 하는 것을 "1일 1커밋"이라고 합니다.

이동욱 개발자님은 거의 매년 1일 1커밋을 쉬지않고 해오고 있습니다.
이런 사람은 굳이 말로 하지 않아도, 얼마나 열정이 있고 성실한지 "증거"를 통해 알 수 있겠죠?
```

***

```
우리는 이런 포트폴리오를 이제 어떻게 관리한다구요? 바로 Github를 써서 관리하는 것이죠.
```

***

```
우리가 휴대폰으로 사진을 찍으면, 그 사진은 우리 휴대폰에만 있습니다.
만약 친구에게 보여주려면 휴대폰을 직접 들고가서 친구에게 보여줘야 겠죠?

하지만, 인스타그램이라는 SNS에 올린다면 굳이 친구를 만나지 않아도 되겠죠?
친구는 내 계정에 들어가서 내가 올린 사진을 원격으로 볼 수 있기 때문입니다.
```

***

```
마찬가지로, Git을 이용해서 내 컴퓨터에서 관리한 버전들은 내 컴퓨터 안에만 있습니다.
그렇기 때문에 이것을 다른 사람에게 보여주려면, 인스타그램 같은 공유 저장소에 올려야합니다.

즉 Github가 이런 역할을 하게됩니다. 내가 수행한 프로젝트, 공부, 프로그램 등등을 올리는 곳이죠.

하지만 주의할 점이 있습니다. 그렇다고 Github가 Instagram일까요?
아닙니다! Github는 SNS의 역할도 물론 할 수 있지만, 원래의 목적은 협업을 위한 공유 저장소입니다.
멀리 떨어진 동료와도 같이 협업하고, 이를 여러 개발자들과 나누는 목적이 더 강합니다.
SNS으로의 비유는 단지 이해하기 쉬운 예시일 뿐입니다.
```

***

```
우리가 아까 배웠던 "분산 버전 관리" 그림과 연결지어서 한번 더 생각해보죠.
```

***

```
Git과 Github 그림을 넣어보면 이렇게 볼 수 있겠습니다.

즉 각 사용자는 자신의 컴퓨터에서 Git으로 어떤 프로그램을 버전관리하고
그 버전들을 Github라는 곳에 올리면서 다른 사용자들과 공유할 수 있습니다.

그리고 Github 서버가 불타더라도? 각 사용자의 버전들은 안전하다는 것을 우리는 이제 알죠.
```

***

```
그럼 Github만 이런 공유 저장소 서비스를 제공할까요? 물론 아닙니다.

Gitlab과 Bitbucket이라는 서비스도 있습니다. 조금씩 차이는 있지만 엄청 다른 서비스는 아닙니다.

나중에 취직을 하게 되면 각 회사에서 사용하는 서비스가 있을 텐데, 그 서비스를 사용하면 됩니다.
```

***

```
그럼 우리는 왜 여러 서비스 중 Github를 배울까요?

바로 점유율 때문입니다. 통계치를 보면 알 수 있듯 가장 많이 사용하는 것이 Github입니다.
```

***

```
마지막으로 정리해봅시다.

우리는 처음으로 Git을 통한 버전관리를 왜 하는가? 에 대해 알아보았습니다.

"뉘앙스" -> "날짜 및 시간" -> "변경사항" -> "변경사항만" 과 같은 식으로 버전관리의 시스템을
업그레이드 했습니다. 

이는 결국 "백업, 복구, 협업"을 위한 것이며 그를 위해 분산 버전 관리 시스템인 Git을 사용한다고 
했습니다.

두번째로는 왜 Github를 통해 포트폴리오를 관리하는가? 에 대해 알아보았습니다.

여행사의 인사팀장이 되어 봤듯이, 잘 관리된 포트폴리오는 아주 좋은 인상을 줍니다.
개발자들은 Github라는 것을 통해 포트폴리오를 관리하고 1일 1커밋도 한다고 알아보았습니다.

분산 버전 관리에서의 중앙 서버를 Github라는 것이 담당할 수 있고, 이를 통해
멀리 떨어진 다른 개발자들과도 협업할 수 있다고 말씀드렸습니다.

그리고 Github가 여러 서비스 중 가장 점유율이 높고 그래서 우리는 Github를 배운다고도
말씀드렸습니다.

우리는 숲을 먼저 보았습니다. 앞으로의 나무(이론)들은 이 숲에서 벗어나지 않습니다.
우리는 숲을 먼저 봄으로써, 앞으로의 학습 동기부여와 방향성을 확립하고자 했습니다.

결국 나중에 누군가가 여러분에게 "왜 Git과 Github를 배웠고 쓰는가?" 라고 물어본다면
위의 2 가지 이유를 말하면서 "그렇기 때문에 많은 곳에서 Git과 Github를 쓰고 나도 쓸거다." 라고
얘기할 수 있다면 이 수업은 성공적일 것입니다.
```
